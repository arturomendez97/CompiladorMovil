options {
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  STATIC = true;

  LOOKAHEAD = 1;
  FORCE_LA_CHECK = false;
  DEBUG_LOOKAHEAD = false;

  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;

  SANITY_CHECK = true;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;

  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
}

PARSER_BEGIN(comp)
package com.example.myapplication.parser;
import com.example.myapplication.TokenAsignaciones.TokenAsignaciones;
import com.example.myapplication.TokenAsignaciones.Quadruple;


public class comp {

}







PARSER_END(comp)

/**
 * Root Production
 */


/**
 * Matching parentheses production.
 */


////////////////////////////////////////////////////////////////////////////
///////////////////////////////TOKENS///////////////////////////////////////

// Establecer tokens y palabras reservadas
// Se separan en bloques que contienen tokens y palabras reservadas del mismo tipo

// Palabras reservadas
TOKEN:
{
    <MAIN: "main" > {System.out.println("MAIN-> "+image);} //1
    | <PROGRAMA: "program" > {System.out.println("PROGRAMA -> "+image);} //2
    | <VAR: "var" > {System.out.println("VAR -> "+image);} //3
    | <INT: "int" > {System.out.println("INT -> "+image);} //4
    | <FLOAT: "float" > {System.out.println("FLOAT -> "+image);} //5
    | <CHAR: "char" > {System.out.println("CHAR -> "+image);} //6
    | <VOID: "void" > {System.out.println("VOID -> "+image);} //7
    | <MODULE: "module" > {System.out.println("MODULE -> "+image);} //8
    | <RETURN: "return" > {System.out.println("RETURN -> "+image);} //9
    | <READ: "read" > {System.out.println("READ -> "+image);} //10
    | <WRITE: "write" > {System.out.println("WRITE -> "+image);} //11
    | <IF: "if" > {System.out.println("IF -> "+image);} //12
    | <THEN: "then" > {System.out.println("THEN -> "+image);} //13
    | <ELSE: "else" > {System.out.println("ELSE -> "+image);} //14
    | <WHILE: "while" > {System.out.println("WHILE -> "+image);} //15
    | <DO: "do" > {System.out.println("DO -> "+image);} //16
    | <FOR: "for" > {System.out.println("FOR -> "+image);} //17
    | <TO: "to" > {System.out.println("TO -> "+image);} //18
    | <CALL: "call" > {System.out.println("CALL -> "+image);} //19
}

// Separadores
TOKEN:
{
    <PARENIZQ: "(" > {System.out.println("PARENIZQ -> "+image);} //20
    | <PARENDER: ")" > {System.out.println("PARENDER -> "+image);} //21
    | <CURLYIZQ: "{" > {System.out.println("CURLYIZQ -> "+image);} //22
    | <CURLYDER: "}" > {System.out.println("CURLYDER -> "+image);} //23
    | <COMMA: "," > {System.out.println("COMMA -> "+image);} //24
    | <COLON: ":" > {System.out.println("COLON -> "+image);} //25
    | <SEMICOLON: ";" > {System.out.println("SEMICOLON -> "+image);} //26
}


// Operadores aritmeticos
TOKEN:
{
    <MAS: "+" > {System.out.println("MAS -> "+image);} //27
    | <MENOS: "-" > {System.out.println("MENOS -> "+image);} //28
    | <MULT: "*" > {System.out.println("MULT -> "+image);} //29
    | <DIV: "/" > {System.out.println("DIV -> "+image);} //30
}

// Operadores Lógicos
TOKEN:
{
    <ASIGNACION: "=" > {System.out.println("ASIGNACION -> "+image);} //31
    | <MASQUE: ">" > {System.out.println("MASQUE -> "+image);} //32
    | <MENOSQUE: "<" > {System.out.println("MENOSQUE -> "+image);} //33
    | <IGUAL: "==" > {System.out.println("IGUAL -> "+image);} //34
    | <NOIGUAL: "!=" > {System.out.println("NOIGUAL -> "+image);} //35
    | <AND: "&" > {System.out.println("AND -> "+image);} //36
    | <OR: "|" > {System.out.println("OR -> "+image);} //37
}

// Valores
TOKEN:
{
    <CTEI: (["0"-"9"])+ > {System.out.println("CTEI -> "+image);} //38
    | <CTEF: (["0"-"9"])+["."](["0"-"9"])+ > {System.out.println("CTEF -> "+image);} //39
    | <ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])* > {System.out.println("ID -> "+image);} //40
    | <CTEC : "'"["a"-"z","A"-"Z","0"-"9"]"'" >//41

}
/// Tokens que se olvidaron
TOKEN:
{
    <BRACKETIZQ: "[" > {System.out.println("BRACKETIZQ -> "+image);} //42
    | <BRACKETDER: "]" > {System.out.println("BRACKETDER -> "+image);} //43
    | <COMILLA: "'" > {System.out.println("COMILLA -> "+image);} //44
    | <MAYORIGUAL: ">=" > {System.out.println("MAYORIGUAL -> "+image);} //45
    | <MENORIGUAL: "<=" > {System.out.println("MENORIGUAL -> "+image);} //46
    | <BOOL: "bool" > {System.out.println("BOOL -> "+image);} //47


}


SKIP :
{
    " " | "\r\n" | "\t" | "\n"
}


////////////////////////////////////////////////////////////////////////////
///////////////////////////////Gramática////////////////////////////////////


//////////////PROGRAMA/////////////////
void Programa() :
{
	//TokenAsignaciones.SetTables();
	///cuboSemantico.constructor();
	Token var;
}
{
    {
	    //Crea goto a main
        creaCuadruploGoto();
     }
    <PROGRAMA><ID><SEMICOLON>Mis_Vars_Global()Mis_Func()Main()
    creaCuadruploEnd()
    <EOF>//
    {

        TokenAsignaciones.printCuadruplos();
        System.out.println("Pila Saltos: " + TokenAsignaciones.returnPilaSaltos());
        System.out.println("Pila VP: " + TokenAsignaciones.returnPilaVP());



        TokenAsignaciones.comienzaMaquinaVirtual();



        TokenAsignaciones.emptyPilaOP();
        TokenAsignaciones.emptyPilaVP();
        TokenAsignaciones.emptyCuadruplos();
        // RESETEAR TODOS LOS CONTADORES
        TokenAsignaciones.resetContsGlobal();
        TokenAsignaciones.resetContsLocal();
        TokenAsignaciones.resetContsTemporal();
        TokenAsignaciones.resetContsConstantes();
        TokenAsignaciones.emptyPilaSaltos();
        TokenAsignaciones.resetContCuadruplos();
        //TokenAsignaciones.printNumVarsGlobal();
        TokenAsignaciones.resetNumVarsGlobal();
    }
}

void creaCuadruploEnd() :
{}
{
    {
         Quadruple quad = new Quadruple("END", null, null, null);
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();
    }
}

//////////////MIS_VARS_GLOBAL/////////////////
void Mis_Vars_Global() :
{}
{
        Vars_Global()
    |   Empty()
}

void Vars_Global() :
{}
{
    <VAR>Vars2_Global()
}

void Vars2_Global() :
{
	int td;
	Token var;
}
{
    td = Tipo()
    {
        TokenAsignaciones.aumentaVarFuncGlobal(td);
    }
    var = <ID>
    {TokenAsignaciones.InsertarSimboloGlobal(var, td);}
    Dim()
    MasV_Global( td ) <SEMICOLON> MasT_Global()
}


void MasV_Global( int td) :
{
    Token var;
}
{
        <COMMA>
        var = <ID>
        {
            TokenAsignaciones.aumentaVarFuncGlobal(td);
            TokenAsignaciones.InsertarSimboloGlobal(var, td);
        }
        Dim()
        MasV_Global(td)
     | Empty()

}

void MasT_Global() :
{}
{
        Vars2_Global()
      | Empty()
}



//////////////MIS_VARS/////////////////
void Mis_Vars(Token func) :
{}
{
      Vars(func)
    | Empty()

}

void Vars(Token func) :
{}
{
    <VAR>Vars2(func)
}

void Vars2(Token func) :
{
	int td;
	Token var;
	String res;
}
{
    td = Tipo()
    {
        TokenAsignaciones.aumentaVarFunc(td, func);
    }
    var = <ID>
    {
		res = TokenAsignaciones.InsertarSimbolo(var, td, func);

		if(res != " ")
		{
		    throw new ParseException(res);
		}
	}
    Dim()
    MasV( td, func ) <SEMICOLON> MasT(func)
}

void Dim() :
{}
{
        <BRACKETIZQ><CTEI><BRACKETDER>MasDim()
      | Empty()
}

void MasDim() :
{}
{
        <BRACKETIZQ><CTEI><BRACKETDER>
      | Empty()
}

void Dim_Expresion(Token func) :
{}
{
        <BRACKETIZQ>Expresion(func)<BRACKETDER>MasDim_Expresion(func)
      | Empty()
}

void MasDim_Expresion(Token func) :
{}
{
        <BRACKETIZQ>Expresion(func)<BRACKETDER>
      | Empty()
}

void MasV( int td, Token func ) :
{
    Token var;
}
{
        <COMMA>
        var = <ID>
        {
            TokenAsignaciones.aumentaVarFunc(td, func);
            TokenAsignaciones.InsertarSimbolo(var, td, func);
        }

        MasV( td ,func)
     | Empty()

}

void MasT(Token func) :
{}
{
        Vars2(func)
      | Empty()
}



//////////////MIS_FUNC/////////////////
void Mis_Func() :
{}
{
        Funcion()
    |   Empty()
}

void Funcion() :
{
    int td;
	Token func;
	String res;
}
{
    <MODULE>
    td = Func1()
    func = <ID>
    {
		res = TokenAsignaciones.InsertarFuncion(func, td, TokenAsignaciones.getContCuadruplos());
        TokenAsignaciones.InsertarVarReturnFuncion(func, td);
        TokenAsignaciones.aumentaVarFuncGlobal(td);
		if(res != " ")
                {
                    throw new ParseException(res);
                }
	}
    <PARENIZQ>Func2(func)<PARENDER>

    Func3(func)
    <CURLYIZQ>
    Func4(func)
    <CURLYDER>

    {
        //RESETEAR LOS CONTS
        TokenAsignaciones.resetContsLocal();
        TokenAsignaciones.resetContsTemporal();
        creaCuadruploEndFunc();
        //TokenAsignaciones.printNumVars(func);
    }
    Mas_F()
}

void creaCuadruploEndFunc() :
{}
{
    {
        Quadruple quad = new Quadruple("ENDFUNC", null, null, null );
        TokenAsignaciones.meterCuadruplo(quad);
        TokenAsignaciones.subeContCuadruplos();
    }
}

int Func1() :
{
    int td;
}
{
        td = Tipo_Retorno()
        {
            return td;
        }
    |   Empty()
}

void Func2(Token func) :
{}
{
        Parametros_Func(func)
    |   Empty()
}

void Func3(Token func) :
{}
{
        Mis_Vars(func)
    |   Empty()
}

void Func4(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

void Mas_F() :
{}
{
        Funcion()
    |   Empty()
}

//////////////TIPO_RETORNO/////////////////
int Tipo_Retorno() :
{}
{
        (<INT> {return 4;})
    |   (<FLOAT> {return 5;})
    |   (<CHAR> {return 6;})
    |   (<VOID> {return 7;})
}

//////////////MAIN/////////////////
void Main() :
{

	Token func;
}
{
    {rellenaCuadruploGoto();}

     func =<MAIN>
     {
     		TokenAsignaciones.InsertarMain(func);
     }
     <PARENIZQ><PARENDER><CURLYIZQ>Main2(func)<CURLYDER>
}



void Main2(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

//////////////PARAMETROS_FUNC/////////////////

void Parametros_Func( Token func) :
{
    int td;
    Token var;
    String res;
}
{
        td = Tipo()
        {
            TokenAsignaciones.aumentaVarFunc(td, func);
        }
        var = <ID>
        {
            TokenAsignaciones.InsertarSimbolo(var, td, func);
            res = TokenAsignaciones.InsertarParametrosFunc(td, func);
            if (res != " ")
            {
                throw new ParseException(res);
            }

        }
        Dim_Expresion(func)
        Params_Func(func)
     |  Empty()
}

void Params_Func( Token func ) :
{}
{
        <COMMA> Parametros_Func(func)
     |  Empty()
}

//////////////PARAMETROS/////////////////

void Parametros( Token func, Token funcLlamada) :
{
    Token var;
}
{
        Expresion(func)
        creaCuadruploParametro(func, funcLlamada)
        //{System.out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + TokenAsignaciones.getParams(funcLlamada));}
        Params(func, funcLlamada)
     |  Empty()
}

void creaCuadruploParametro(Token func, Token funcLlamada) :
{
     Token arg1;
     Token par = new Token();
     int aux;
     int contParams;
}
{
    {
         arg1 = TokenAsignaciones.popPilaVP();
         contParams = TokenAsignaciones.getContParams();
         par.image = "par" + Integer.toString(contParams);


         //El if es para cuando es un temporal o una constante
         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else
         {
             aux = TokenAsignaciones.getType(arg1, func);
         }


         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;

         //System.out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + TokenAsignaciones.getContParams());

         if (!TokenAsignaciones.checaTipoParams(aux, funcLlamada))
         {
             TokenAsignaciones.resetContParams();
            throw new ParseException("El parametro enviado no es del mismo tipo que el declarado o es un parametro extra");
         }


         Quadruple quad = new Quadruple("PARAM", arg1, null, par);
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();

             //quad.print();
    }
}

void Params( Token func, Token funcLlamada) :
{}
{
        <COMMA> Parametros(func, funcLlamada)
     |  Empty()
}

//////////////LECTURA/////////////////
void Lectura(Token func) :
{
    Token op;
}
{
    op = <READ>
    <PARENIZQ>Lectura2(func, op)<PARENDER><SEMICOLON>
}

void Lectura2(Token func, Token op) :
{}
{
        Variable(func)
        creaCuadruploLectura(op, func)
        Lectura3(func, op)


}
void Lectura3(Token func, Token op) :
{}
{
        <COMMA>Lectura2(func, op)
      | Empty()

}

void creaCuadruploLectura(Token op, Token func) :
{
     Token arg1;
     int aux;
}
{
    {
    arg1 = TokenAsignaciones.popPilaVP();

    //Entra qui si el argumento es un temporal, porque su tipo
    if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 )
    {
        aux = arg1.kind;
    }
    else{
        aux = TokenAsignaciones.getType(arg1, func);
        }

    arg1.image = tokenToDir(arg1, func);
    arg1.kind = aux;

    Quadruple quad = new Quadruple(op.image, arg1, null, null);
    TokenAsignaciones.meterCuadruplo(quad);
    TokenAsignaciones.subeContCuadruplos();
    //quad.print();
     }
}


//////////////ESCRITURA/////////////////
void Escritura(Token func) :
{
    Token op;
}
{
    op = <WRITE><PARENIZQ>Escritura2(op, func)<PARENDER><SEMICOLON>
}

void Escritura2(Token op, Token func) :
{
    Token var;
}
{
        var = <CTEC>
        {
            var.image = TokenAsignaciones.InsertarConstante(var.image, TokenAsignaciones.getContConst(var.kind));
            TokenAsignaciones.pushPilaVP(var);
            creaCuadruploEscritura(op, func);
        }


        Escritura3(op, func)


    |   Expresion(func)
        {creaCuadruploEscritura(op, func);}
        Escritura3(op, func)
}

void Escritura3(Token op, Token func) :
{}
{
        <COMMA>Escritura2(op, func)
    |   Empty()
}

void creaCuadruploEscritura(Token op, Token func) :
{
     Token arg1;
     int aux;
}
{
    {
         arg1 = TokenAsignaciones.popPilaVP();

         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else{
             aux = TokenAsignaciones.getType(arg1, func);
         }

         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;


         Quadruple quad = new Quadruple(op.image, null, null, arg1);
         TokenAsignaciones.meterCuadruplo(quad);
             TokenAsignaciones.subeContCuadruplos();

             //quad.print();
    }
}

/*
void Letrero() :
{}
{
    <COMILLA> <ID> <COMILLA>
}
*/

//////////////ESTATUTO DE DECISION/////////////////
void Estatuto_De_Decision(Token func) :
{}
{
    <IF><PARENIZQ>Expresion(func)
    {
        System.out.println("VECTOR POLACO DESPUES DE LA EXP: " + TokenAsignaciones.returnPilaVP());
    }
    creaCuadruploGotoF(func) <PARENDER><THEN><CURLYIZQ>EDD2(func)<CURLYDER>
    rellenaCuadruploGotoF()
    EDD3(func)
    rellenaCuadruploGoto()
}

void rellenaCuadruploGotoF() :
{
    int cuadruploActual;
    int cuadruploModificar;
    int cuadruploExtra;
}
{
    {
        cuadruploActual = TokenAsignaciones.getContCuadruplos();
        //Haces pop de los últimos dos, y agarras el de mero atras
        cuadruploExtra = TokenAsignaciones.popPilaSaltos();
        cuadruploModificar = TokenAsignaciones.popPilaSaltos();
        //Regresas el otro
        TokenAsignaciones.pushPilaSaltos(cuadruploExtra);
        TokenAsignaciones.completaGOTO(cuadruploModificar, cuadruploActual);
    }
}

void rellenaCuadruploGoto() :
{
    int cuadruploActual;
    int cuadruploModificar;
}
{
    {
        cuadruploActual = TokenAsignaciones.getContCuadruplos();
        cuadruploModificar = TokenAsignaciones.popPilaSaltos();
        TokenAsignaciones.completaGOTO(cuadruploModificar, cuadruploActual);
    }
}

void creaCuadruploGotoF(Token func) :
{
     Token arg1;
     int aux;
}
{
    {
         arg1 = TokenAsignaciones.popPilaVP();


         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else{
             aux = TokenAsignaciones.getType(arg1, func);
         }

         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;

         if ( aux != 47)
         {
             throw new ParseException("La expresion dentro del if tiene que ser bool, recibio un tipo:  " + aux);
         }


         Quadruple quad = new Quadruple("GOTOF", arg1, null, null );
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.pushPilaSaltos(TokenAsignaciones.getContCuadruplos());
         TokenAsignaciones.subeContCuadruplos();


             //quad.print();
    }
}

void creaCuadruploGoto() :
{
     int aux;
}
{
    {

         Quadruple quad = new Quadruple("GOTO", null, null, null );
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.pushPilaSaltos(TokenAsignaciones.getContCuadruplos());
         TokenAsignaciones.subeContCuadruplos();
    }
}

void EDD2(Token func) :
{}
{
        Estatuto(func)
        {creaCuadruploGoto();}
    |   Empty()
        {creaCuadruploGoto();}
}

void EDD3(Token func) :
{}
{
        <ELSE><CURLYIZQ>EDD4(func)<CURLYDER>
    |   Empty()
}

void EDD4(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

//////////////ASIGNACION/////////////////

Token Asignacion( Token func) :
{
    Token op;
    Token var;
}
{
    var = Variable(func)
    op = <ASIGNACION>
    Expresion(func)
    creaCuadruploAsignacion(op, func)
    {         TokenAsignaciones.printCuadruplos();}
    <SEMICOLON>
    {
        return var;
    }
}

//////////////CREA CUADRUPLO GENERICO/////////////////


void creaCuadruploAsignacion(Token op, Token func) :
{
     Token arg1  = new Token();
     Token arg2  = new Token();
     Token tAux;
     Token tAux2;
     int aux;
     int aux2;
}
{
    {
         tAux = TokenAsignaciones.popPilaVP();
         tAux2 = TokenAsignaciones.popPilaVP();

         arg1.image = tAux.image;
         arg1.kind = tAux.kind;

         arg2.image = tAux2.image;
         arg2.kind = tAux2.kind;

         System.out.println("arg1 image: " + arg1.image);

         System.out.println("arg1 kind: " + arg1.kind);




         //El if es para cuando es un temporal o una constante
         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else
         {
             aux = TokenAsignaciones.getType(arg1, func);
         }

         if ( arg2.kind == 4 | arg2.kind == 5 | arg2.kind == 6 | arg2.kind == 47 | arg2.kind == 38 | arg2.kind == 39 | arg2.kind == 41)
         {
             aux2 = arg2.kind;
         }
         else{
             aux2 = TokenAsignaciones.getType(arg2, func);
         }

         System.out.println("aux: " + aux);

         //System.out.println("aux2: " + aux2);


         if (TokenAsignaciones.getCuboType(aux2,aux,op.image) == 0)
             {
                 throw new ParseException("Los argumentos: " + arg1.image + " y " + arg2.image + " no son compatibles.");
             }

         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;
         arg2.image = tokenToDir(arg2, func);
         arg2.kind = aux;


         Quadruple quad = new Quadruple(op.image, arg1, null, arg2);
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();
    }
}

//////////////VARIABLE/////////////////
Token Variable(Token func) :
{
    Token var;
    String res;
    boolean imp = false;
}
{
    var = <ID>
    {
        res = TokenAsignaciones.checkVariable(var, func);

        if(res != " ")
        {
            throw new ParseException(res);
            imp = true;
        }

        TokenAsignaciones.pushPilaVP(var);
        //System.out.println(TokenAsignaciones.returnPilaVP());
    }
    Dim_Expresion(func)
    {
    return var;
    }
}

//////////////TIPO/////////////////
int Tipo() :
{}
{
        (<INT> {return 4;})
    |   (<FLOAT> {return 5;})
    |   (<CHAR> {return 6;})
}

//////////////RETORNO/////////////////
void Retorno(Token func) :
{
    Token op;
}
{
    op=<RETURN>
    <PARENIZQ>Expresion(func)<PARENDER><SEMICOLON>
    validaReturn(func)
    creaCuadruploRetorno(op, func)
}

void validaReturn(Token func) :
{}
{
    {
        if(!TokenAsignaciones.getTypeFunc(func))
        {
            throw new ParseException("La funcion " + func.image + " es de tipo void, asi que no puede tener un return");
        }
    }
}

void creaCuadruploRetorno(Token op, Token func) :
{
     Token arg1;
     int aux;
}
{
    {
         arg1 = TokenAsignaciones.popPilaVP();

         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else{
             aux = TokenAsignaciones.getType(arg1, func);
         }

         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;

         if (TokenAsignaciones.getfunctipo(func) != aux)
         {
             throw new ParseException("Lo que se regresa en la función " + func + " debe de ser del mismo tipo que la función");
         }


         Quadruple quad = new Quadruple(op.image, arg1, null, func);
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();

             //quad.print();
    }
}

//////////////CONDICIONAL/////////////////
void Condicional(Token func) :
{}
{
    {TokenAsignaciones.pushPilaSaltos(TokenAsignaciones.getContCuadruplos());}
    <WHILE><PARENIZQ>Expresion(func)
    creaCuadruploGotoF(func)
    <PARENDER><DO><CURLYIZQ>Condicional2(func)<CURLYDER>
    creaYRellenaGoto(func)
    rellenaCuadruploGotoFCondicional()

}

void Condicional2(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

void creaYRellenaGoto(Token func) :
{
     int aux;
     int cuadruploActual;
     int cuadruploExtra;
     int resultado;
     Token aux2 = new Token();
}
{
    {
         //Haces pop de los últimos dos, y agarras el de mero atras
         cuadruploExtra = TokenAsignaciones.popPilaSaltos();
         resultado = TokenAsignaciones.popPilaSaltos();
         //Regresas el otro
         TokenAsignaciones.pushPilaSaltos(cuadruploExtra);

         //A la hora de generar el cuadruplo, ya sabemos a donde lleva. Así que se lo ponemos de una vez
         aux2.image = Integer.toString(resultado);
         Quadruple quad = new Quadruple("GOTO", null, null, aux2 );
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();
    }
}


void rellenaCuadruploGotoFCondicional() :
{
    int cuadruploActual;
    int cuadruploModificar;
}
{
    {
        cuadruploActual = TokenAsignaciones.getContCuadruplos();
        cuadruploModificar = TokenAsignaciones.popPilaSaltos();
        TokenAsignaciones.completaGOTO(cuadruploModificar, cuadruploActual);
    }
}

void rellenaCuadruploGotoCondicional() :
{
    int cuadruploActual;
    int cuadruploModificar;
}
{
    {
        cuadruploActual = TokenAsignaciones.getContCuadruplos();
        cuadruploModificar = TokenAsignaciones.popPilaSaltos();
        TokenAsignaciones.completaGOTO(cuadruploModificar, cuadruploActual);
    }
}

//////////////NO_CONDICIONAL/////////////////
void No_condicional(Token func) :
{
    Token var;
}
{
    <FOR>
    var = Asignacion(func)
    {TokenAsignaciones.pushPilaSaltos(TokenAsignaciones.getContCuadruplos());}
    <TO>Expresion(func)

    creaCuadruploGotoF(func)
    <DO><CURLYIZQ>No_condicional2(func)
    creaCuadruploSuma(var, func)
    creaYRellenaGoto(func)
    rellenaCuadruploGotoFCondicional()
    <CURLYDER>
}



void creaCuadruploSuma(Token var, Token func) :
{
    Token aux = new Token();
}
{
    {
        aux.image = "1";
        Quadruple quad = new Quadruple("+", var, aux, var );
        TokenAsignaciones.meterCuadruplo(quad);
        TokenAsignaciones.subeContCuadruplos();
    }

}

void No_condicional2(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

//////////////Llamada/////////////////
Token Llamada( Token func ) :
{
	Token funcLlamada;
    String res;
	boolean imp = false;
}
{
    <CALL>
    funcLlamada = <ID>
    {
    res = TokenAsignaciones.checkFuncion(funcLlamada);

        if(res != " ")
        {
            throw new ParseException(res);
            imp = true;
        }
        creaCuadruploEra(funcLlamada);
    }
    <PARENIZQ>Llamada2(func, funcLlamada)<PARENDER>
    creaCuadruploGoSub(funcLlamada)
    {TokenAsignaciones.pushPilaVP(funcLlamada);}
    //creaCuadruploRecibirValor(funcLlamada, func)
    {return funcLlamada;}
}
/*
void creaCuadruploRecibirValor( Token funcLlamada, Token func) :
{
     Token arg1;
     Token arg2;
     Token op  = new Token();
     int aux;
     int aux2;
}
{
    {
         arg1 = TokenAsignaciones.popPilaVP();
         arg2 = funcLlamada;
        op.image = "=";


         //El if es para cuando es un temporal o una constante
         if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
         {
             aux = arg1.kind;
         }
         else
         {
             aux = TokenAsignaciones.getType(arg1, func);
         }

         if ( arg2.kind == 4 | arg2.kind == 5 | arg2.kind == 6 | arg2.kind == 47 | arg2.kind == 38 | arg2.kind == 39 | arg2.kind == 41)
         {
             aux2 = arg2.kind;
         }
         else{
             aux2 = TokenAsignaciones.getType(arg2, func);
         }

         //System.out.println("aux: " + aux);

         //System.out.println("aux2: " + aux2);

         if (TokenAsignaciones.getCuboType(aux2,aux,op.image) == 0)
             {
                 throw new ParseException("Los argumentos: " + arg1.image + " y " + arg2.image + " no son compatibles.");
             }

         arg1.image = tokenToDir(arg1, func);
         arg1.kind = aux;
         arg2.image = tokenToDir(arg2, func);
         arg2.kind = aux;


         Quadruple quad = new Quadruple(op.image, arg1, null, arg2);
         TokenAsignaciones.meterCuadruplo(quad);
             TokenAsignaciones.subeContCuadruplos();

             //quad.print();
    }
}

*/
void creaCuadruploGoSub(Token funcLlamada) :
{
     Token aux = new Token();
}
{
    {
         aux.image = Integer.toString(TokenAsignaciones.getInitialAddress(funcLlamada));
         Quadruple quad = new Quadruple("GOSUB", funcLlamada, null, aux );
         TokenAsignaciones.meterCuadruplo(quad);
         TokenAsignaciones.subeContCuadruplos();
    }
}

void creaCuadruploEra(Token var) :
{
     int aux;
}
{
    {
         Quadruple quad = new Quadruple("ERA", null, null, var);
         TokenAsignaciones.meterCuadruplo(quad);
         //System.out.print("EL CUADRUPLO DEL ERA: "  + TokenAsignaciones.getContCuadruplos());
         TokenAsignaciones.subeContCuadruplos();
    }
}

void Llamada2( Token func , Token funcLlamada) :
{}
{
        Parametros(func, funcLlamada)
        {
            if(TokenAsignaciones.getParamSize(funcLlamada) != TokenAsignaciones.getContParams())
            {
                TokenAsignaciones.resetContParams();
                throw new ParseException("En la llamada a la funcion " + funcLlamada + " se enviaron menos parametros de los necesitados.");
            }
            TokenAsignaciones.resetContParams();
        }
    |   Empty()
}

//////////////ESTATUTO/////////////////
void Estatuto(Token func) :
{}
{
        Asignacion(func)Estatuto2(func) //Cuadruplos listos
    |   Lectura(func)Estatuto2(func) // Cuadruplos listos
    |   Escritura(func)Estatuto2(func) // Cuadruolos listos
    |   Retorno(func)Estatuto2(func) // Cuadruplos listos
    |   Estatuto_De_Decision(func)Estatuto2(func) // Cuadruplos listos
    |   Condicional(func)Estatuto2(func) // Cuadruplos listos
    |   No_condicional(func)Estatuto2(func) // Cuadruplos listos
    |   Llamada(func)<SEMICOLON>Estatuto2(func) // Cuadruplos listos (Checar el tipo)
}


void Estatuto2(Token func) :
{}
{
        Estatuto(func)
    |   Empty()
}

//////////////EXPRESION/////////////////
Token Expresion(Token func) :
{
    Token var;
}
{
    var = T_Exp(func)


    {
        if (TokenAsignaciones.checkPilaOP("|"))
            {
                creaCuadruploExp(func);
            }

    }
    Expresion2(func)
    {return var;}
}

void Expresion2(Token func) :
{
    Token var;
}
{
        var = <OR>  {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} Expresion(func)
    |   Empty()
}

//////////////T_Exp/////////////////
Token T_Exp(Token func) :
{
    Token var;
}
{
    var = G_Exp(func)

    {
            if (TokenAsignaciones.checkPilaOP("&"))
                {

                    creaCuadruploExp(func);
                }
        }
    T_Exp2(func)
        {return var;}

}

void T_Exp2(Token func) :
{
    Token var;
}
{
        var= <AND> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} T_Exp(func)
    |   Empty()
}

//////////////G_Exp/////////////////
Token G_Exp(Token func) :
{
    Token var;
}
{
   var = M_Exp(func)
   {
           if (TokenAsignaciones.checkPilaOP("<") | TokenAsignaciones.checkPilaOP(">") | TokenAsignaciones.checkPilaOP("==") | TokenAsignaciones.checkPilaOP("!=") | TokenAsignaciones.checkPilaOP(">=") | TokenAsignaciones.checkPilaOP("<="))
               {
                   creaCuadruploExp(func);
               }
       }
   G_Exp2(func)
       {return var;}

}

void G_Exp2(Token func) :
{
    Token var;
}
{
        var = <MENOSQUE> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   var = <MASQUE> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   var = <IGUAL> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   var = <NOIGUAL> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   var = <MAYORIGUAL> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   var = <MENORIGUAL> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} G_Exp(func)
    |   Empty()
}

//////////////M_Exp/////////////////
Token M_Exp(Token func) :
{
    Token var;
}
{
    var = T(func)

    {
        if (TokenAsignaciones.checkPilaOP("+") | TokenAsignaciones.checkPilaOP("-"))
        {
            creaCuadruploExp(func);
        }
    }
    M_Exp2(func)
        {return var;}

}

void M_Exp2(Token func) :
{
    Token var;
}
{
        var = <MAS> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} M_Exp(func)
    |   var = <MENOS>  {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} M_Exp(func)
    |   Empty()
}

//////////////T(TERMINO)/////////////////
Token T(Token func) :
{
    Token var;
}
{
    var = F(func)

    {
        if (TokenAsignaciones.checkPilaOP("*") | TokenAsignaciones.checkPilaOP("/"))
        {
            creaCuadruploExp(func);
        }
    }
    T2(func)
        {return var;}

}


// Esta función hace pop de la pila de operadores, y dos pops de la pila del vector polaco. Con esto llama al cubo Semántico para crear
// un temporal del tipo correspondiente. Crea el cuadruplo con esos 4 elementos, y guarda el temporal en la pila del vector polaco.
void creaCuadruploExp(Token func) :
{
     Token op;
     Token arg1  = new Token();
     Token arg2  = new Token();
     Token tAux;
     Token tAux2;
     int aux;
     int aux2;
     Token temporal;
}
{
    {
    op = TokenAsignaciones.popPilaOP();
    tAux = TokenAsignaciones.popPilaVP();
    tAux2 = TokenAsignaciones.popPilaVP();

    arg1.image = tAux.image;
    arg1.kind = tAux.kind;

    arg2.image = tAux2.image;
    arg2.kind = tAux2.kind;
    temporal = op.newToken(op.kind);
    //System.out.println("image: " + arg1 + " type: " + arg1.kind);
    //System.out.println("image: " + arg2 + " type: " + arg2.kind);

    //Entra qui si el argumento es un temporal, porque su tipo
    if ( arg1.kind == 4 | arg1.kind == 5 | arg1.kind == 6 | arg1.kind == 47 | arg1.kind == 38 | arg1.kind == 39 | arg1.kind == 41)
    {
        aux = arg1.kind;
    }
    else{
        aux = TokenAsignaciones.getType(arg1, func);
        }


    if (  arg2.kind == 4 | arg2.kind == 5 | arg2.kind == 6 | arg2.kind == 47 | arg2.kind == 38 | arg2.kind == 39 | arg2.kind == 41 )
        {
            aux2 = arg2.kind;
        }
        else{
            aux2 = TokenAsignaciones.getType(arg2, func);
            }

    temporal.kind = TokenAsignaciones.getCuboType(aux, aux2, op.image);

        TokenAsignaciones.aumentaVarFuncTemporal(temporal.kind, func);

    //System.out.println("temporal.kind: " + temporal.kind);

    if(temporal.kind == 0)
    {
        throw new ParseException("Los argumentos: " + arg1.image + " y " + arg2.image + " no son compatibles.");
    }
        System.out.println("aaaaaa: " + arg1.image);
        System.out.println("aaaaaa: " + arg2.image);

    ////////////////////////////////////////////////// Aquí cambia los tokens por sus direcciones antes de meterlos.

    arg1.image = tokenToDir(arg1, func);
    arg1.kind = aux;
    arg2.image = tokenToDir(arg2, func);
    arg2.kind = aux;


    temporal.image = String.valueOf(TokenAsignaciones.getContTemporal(temporal.kind));
    TokenAsignaciones.pushPilaVP(temporal);
    Quadruple quad = new Quadruple(op.image, arg1, arg2, temporal);
    TokenAsignaciones.meterCuadruplo(quad);
        TokenAsignaciones.subeContCuadruplos();

    //quad.print();
     }
}


//Esta función convierte un token a una direccion. Cambia su image de ej: b -> 1000
//Si el token es un temporal o constante, lo deja igual porque su image ya es la dirección
String tokenToDir(Token arg, Token func) :
{}
{
    {
    switch (arg.kind)
                {
                    case 4:
                    case 5:
                    case 6:
                    case 47:
                    case 38:
                    case 39:
                    case 41:
                            return arg.image;
                             break;
                    default: return String.valueOf(TokenAsignaciones.getDir(arg, func));
                             break;
                }
     }
}

void T2(Token func) :
{
    Token var;
}
{
        var = <MULT> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} T(func)
    |   var = <DIV> {TokenAsignaciones.pushPilaOP(var); System.out.println(TokenAsignaciones.returnPilaOP());} T(func)
    |   Empty()
}

//////////////F(FACTOR)/////////////////
Token F(Token func) :
{
    Token var;
}
{
        var = <PARENIZQ> {TokenAsignaciones.pushPilaOP(var);}
        var = Expresion(func)<PARENDER> {TokenAsignaciones.popPilaOP();}
        {return var;}
    |   var = Variable(func)
        {return var;}
    |   //{System.out.println("LA PILA ANTES DE ENTRAR A LA LLAMADAAAAAAAAAAAAAAAAAAAAAAA: " + TokenAsignaciones.returnPilaVP());}
        var = Llamada(func)
        {return var;}
    |   var = F2()
        {return var;}
}

Token F2() :
{
    Token var;
}
{
        var = <CTEI>
        {
            var.image = TokenAsignaciones.InsertarConstante(var.image, TokenAsignaciones.getContConst(var.kind));
            TokenAsignaciones.pushPilaVP(var);
            return var;
        }
    |   var = <CTEF>
        {
            var.image = TokenAsignaciones.InsertarConstante(var.image, TokenAsignaciones.getContConst(var.kind));
            TokenAsignaciones.pushPilaVP(var);
            return var;
        }
    |   var = <CTEC>
        {
            var.image = TokenAsignaciones.InsertarConstante(var.image, TokenAsignaciones.getContConst(var.kind));
            TokenAsignaciones.pushPilaVP(var);
            return var;
        }
}


//////////////VACIO/////////////////
void Empty() :
{}
{
   {}

}

